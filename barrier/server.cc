// This autogenerated skeleton file illustrates one way to adapt a synchronous
// interface into an asynchronous interface. You should copy it to another
// filename to avoid overwriting it and rewrite as asynchronous any functions
// that would otherwise introduce unwanted latency.

#include <iostream>
#include <unordered_map>
#include <vector>
#include <thrift/async/TEvhttpServer.h>
#include <thrift/async/TAsyncBufferProcessor.h>
#include <thrift/async/TAsyncProtocolProcessor.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TTransportUtils.h>
#include <thrift/cxxfunctional.h>
#include "../common/config.hh"
#include "../common/definitions.hh"
#include "../thrift/gen-cpp/barrier.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::async;
using namespace ::novalincs::cs::lsd;

using boost::shared_ptr;

struct barrier_s
{
  int32_t const expected;
  std::vector<tcxx::function<void(bool const&)>> pending;

  barrier_s(int32_t const expected)
    : expected(expected)
  {
  }
};
typedef struct barrier_s barrier_t;
typedef std::string bid_t;
typedef std::unordered_map<bid_t, barrier_t*> barrier_map_t;

class barrier_handler : public barrierCobSvIf
{
private:
  barrier_map_t barrier_map;

public:
  barrier_handler() {}

  virtual ~barrier_handler() {}

  void create(tcxx::function<void(bool const&)> cob, std::string const& id,
              int32_t const expected)
  {
    auto it = barrier_map.find(id);
    bool const exists = it != barrier_map.end();
    if (exists) {
      std::cout << "create(" << id << "," << expected << ") ";
      std::cout << "-> already exists" << std::endl;
      cob(false);
    } else {
      barrier_t* barrier = new barrier_t(expected);
      barrier_map.insert(std::make_pair(id, barrier));
      std::cout << "create(" << id << "," << expected << ") ";
      std::cout << "-> ok" << std::endl;
      cob(true);
    }
  }

  void wait(tcxx::function<void(bool const&)> cob, const std::string& id)
  {
    auto it = barrier_map.find(id);
    bool const exists = it != barrier_map.end();
    if (exists) {
      auto* const barrier = it->second;
      barrier->pending.push_back(cob);
      int32_t const arrived = barrier->pending.size();
      std::cout << "wait(" << id << ") -> ok ";
      std::cout << "(" << arrived << "/" << barrier->expected << ")";
      std::cout << std::endl;
      if (arrived == barrier->expected) {
        for (auto& reply : barrier->pending) {
          reply(true);
        }
        barrier->pending.clear();
      }
    } else {
      std::cout << "wait(" << id << ") ";
      std::cout << "-> doesn't exist" << std::endl;
      cob(false);
    }
  }

  void destroy(tcxx::function<void(bool const&)> cob, const std::string& id)
  {
    auto it = barrier_map.find(id);
    bool const exists = it != barrier_map.end();
    if (exists) {
      barrier_t* barrier = it->second;
      int32_t const arrived = barrier->pending.size();
      std::cout << "destroy(" << id << ") -> ok ";
      std::cout << "(" << arrived << "/" << barrier->expected << ")";
      std::cout << std::endl;
      for (auto& reply : barrier->pending) {
        reply(false);
      }
      delete barrier;
      barrier_map.erase(it);
      cob(true);
    } else {
      std::cout << "destroy(" << id << ") ";
      std::cout << "-> doesn't exist" << std::endl;
      cob(false);
    }
  }
};

int
main(const int argc, char const* argv[])
{
  config cfg;
  auto const port = cfg.barrier_port();
  shared_ptr<TProtocolFactory> protocol_factory(
    new TBinaryProtocolFactoryT<TBufferBase>());
  shared_ptr<barrier_handler> async_handler(new barrier_handler());
  shared_ptr<TAsyncProcessor> async_processor(
    new barrierAsyncProcessor(async_handler));
  shared_ptr<TAsyncBufferProcessor> async_buffer_processor(
    new TAsyncProtocolProcessor(async_processor, protocol_factory));
  TEvhttpServer server(async_buffer_processor, port);

  std::cout << "running barrier server on port " << port << std::endl;
  server.serve();
  return 0;
}
